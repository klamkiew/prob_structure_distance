# %%

def rnafold_dp_parse(file_path):
    '''
    Takes a dotplot PostScript file generated by RNAfold and parses the roots
    of base parsing probabilities into a dictionary with coordinates i and j
    for the interactions as keys.

    Parameters:
        file_path (str): File path to a dotplot PostScript file generated by
        RNAfold

    Returns:
        dict: A dictionary with the format {(i, j) : p} where i and p are
        nucleotide coordinates and p is the pairing probability of the
        interaction.
    '''


    # instead of the input = open(file) .... input.close() construct, you can do this:
    """
    with open(file, 'r') as input:
      for line in input:
        if line.startswith("Hello"):
          print("Found a line with hello").
    print("Due to indentation, this line of code is 'outside' of the with-block. Therefore, the file handle has been closed.")
    """
    # the with statement opens and closes your file-handle automatically, so you won't have to take care of this anymore.

    ps_file = open(file_path, "r")
    probability_dictionary = {}
    for line in ps_file:
        line = line.strip()
        if line.endswith("ubox") and not line.startswith("%"):
          # you are using the same command -- line.split(' ') -- three times here.
          # usually, it is better to do it once, e.g.
          # splitLine = line.split()    #split() without parameters will split at ALL whitespaces
          # i = int(splitLine[0])
          # j = int(splitLine[1])
          # ...

            i = int(line.split(" ")[0])
            j = int(line.split(" ")[1])
            p = pow(float(line.split(" ")[2]),2)
            probability_dictionary[(i, j)] = p
    ps_file.close()
    return(probability_dictionary)

# %%

def p_distances_squared(rna_len, pairing_rna1, pairing_rna2):

  # what is the rna_len parameter doing here? It doesn't get used at all, does it?

    '''
    Takes two dictionaries, pairing_rna1 and pairing_rna2, and the length
    of the originating RNA sequence, rna_len, and returns a dictionarry with
    coordinates i and j as keys and the squared between each coordinate.

    Preconditions:
        Both dictionaries, pairing_rna1 and pairing_rna2, should have
        coordinates i and j as keys and pairing probabilities as values.
        The RNA sequences originating the base pairing probabilities must have
        the same size.

    Parameters:
        file_path (str): File path to a dotplot PostScript file generated by
        RNAfold

    Returns:
        dict: A dictionary with the format {(i, j) : pow(p1-p2)} where i and p
        are nucleotide coordinates and p is the pairing probability of the
        interaction.
    '''
    distance_dictionary = {}
    # Selects keys that are on both dictionaries:
    intersection_p = pairing_rna1.keys() & pairing_rna2.keys()
    # Selects keys that are only on the RNA01 dictionary:
    only_pairing_rna1 = pairing_rna1.keys() - pairing_rna2.keys()
    # Selects keys that are only on the RNA02 dictionary:
    only_pairing_rna2 = pairing_rna2.keys() - pairing_rna1.keys()
    for key in intersection_p:
        distance_dictionary[key] = pow(pairing_rna1[key] -
                                       pairing_rna2[key], 2)
    for key in only_pairing_rna1:
        distance_dictionary[key] = pow(pairing_rna1[key], 2)
    for key in only_pairing_rna2:
        distance_dictionary[key] = pow(pairing_rna2[key], 2)
    return(distance_dictionary)

    # this is generally correct, but I feel like this could've been easier with a dict-comprehension.
    # this line is pretty ugly, but just to give you an idea how it could work in general.
    # I didn't include the math.pow() function due to the length of the line
    distance_dict = { key : pairing_rna1[key] - pairing_rna2[key] if key in pairing_rna2 else pairing_rna1[key] for key in pairing_rna1 }. \
                    update( { key : pairing_rna2[key] for key in pairing_rna2 if key not in pairing_rna1 } )
    # to be fair, your code looks a bit cleaner and is probably more read-able ;)




# %%

# Parse base pairing probabilites from PostScript files for two artificial
# RNA sequences.

# In general, you would like to avoid all hard-coded things like paths. So, maybe this would work:
"""
import sys
rna01_pairing_p = rnafold_dp_parse(sys.argv[1])
rna02_pairing_p = rnafold_dp_parse(sys.argv[2])
"""
# that way, the script takes to parameters as an input, but you can easily change those input files without
# changing the code of the script itself.

rna01_pairing_p = rnafold_dp_parse('synthetic_seq_fold/structure01_dp.ps')
rna02_pairing_p = rnafold_dp_parse('synthetic_seq_fold/structure02_dp.ps')

# %%

# Compute the squared distance between base pairing probabilities for both
# sequences.

distances_p_squared = p_distances_squared(66, rna01_pairing_p, rna02_pairing_p)

# %%


# calling sum() here leads to no result on the terminal. In an interactive python shell, you usually get the result of the last command,
# but here nothing would happen. You'd need a print statement (or something similar).

# Sum the distances of individual squared distances
sum(distances_p_squared.values())
